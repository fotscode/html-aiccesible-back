
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>constants: Go Coverage Report</title>
		<style>
			body {
				background: whitesmoke;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: whitesmoke;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(16, 132, 16) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">html-aiccesible/constants/os.go (100.0%)</option>
				
				<option value="file1">html-aiccesible/controllers/AI.go (25.5%)</option>
				
				<option value="file2">html-aiccesible/controllers/comment.go (94.7%)</option>
				
				<option value="file3">html-aiccesible/controllers/config.go (69.2%)</option>
				
				<option value="file4">html-aiccesible/controllers/controller.go (100.0%)</option>
				
				<option value="file5">html-aiccesible/controllers/post.go (78.3%)</option>
				
				<option value="file6">html-aiccesible/controllers/user.go (80.4%)</option>
				
				<option value="file7">html-aiccesible/httputil/response.go (100.0%)</option>
				
				<option value="file8">html-aiccesible/middleware/auth.go (69.4%)</option>
				
				<option value="file9">html-aiccesible/middleware/cors.go (100.0%)</option>
				
				<option value="file10">html-aiccesible/middleware/getters.go (77.8%)</option>
				
				<option value="file11">html-aiccesible/middleware/json.go (100.0%)</option>
				
				<option value="file12">html-aiccesible/middleware/validations.go (76.8%)</option>
				
				<option value="file13">html-aiccesible/models/config.go (100.0%)</option>
				
				<option value="file14">html-aiccesible/models/db.go (59.1%)</option>
				
				<option value="file15">html-aiccesible/models/user.go (71.4%)</option>
				
				<option value="file16">html-aiccesible/repositories/comment.go (91.7%)</option>
				
				<option value="file17">html-aiccesible/repositories/config.go (76.5%)</option>
				
				<option value="file18">html-aiccesible/repositories/post.go (81.8%)</option>
				
				<option value="file19">html-aiccesible/repositories/user.go (82.9%)</option>
				
				<option value="file20">html-aiccesible/routes/routes.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package constants

import "os"

var (
        JWT_SECRET     string
        BCRYPT_COST    string
        MYSQL_USER     string
        MYSQL_PASSWORD string
        MYSQL_DATABASE string
        MYSQL_HOST     string
        MYSQL_PORT     string
        ADMIN_USERNAME string
        ADMIN_PASSWORD string
        OLLAMA_HOST    string
        OLLAMA_PORT    string
)

func init() <span class="cov8" title="1">{
        JWT_SECRET = os.Getenv("JWT_SECRET")
        BCRYPT_COST = os.Getenv("BCRYPT_COST")
        MYSQL_USER = os.Getenv("MYSQL_USER")
        MYSQL_PASSWORD = os.Getenv("MYSQL_PASSWORD")
        MYSQL_DATABASE = os.Getenv("MYSQL_DATABASE")
        MYSQL_HOST = os.Getenv("MYSQL_HOST")
        MYSQL_PORT = os.Getenv("MYSQL_PORT")
        ADMIN_USERNAME = os.Getenv("ADMIN_USERNAME")
        ADMIN_PASSWORD = os.Getenv("ADMIN_PASSWORD")
        OLLAMA_HOST = os.Getenv("OLLAMA_HOST")
        OLLAMA_PORT = os.Getenv("OLLAMA_PORT")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package controllers

import (
        "bytes"
        "encoding/json"
        "fmt"
        ct "html-aiccesible/constants"
        "html-aiccesible/httputil"
        m "html-aiccesible/models"
        "io"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
)

func (b *Controller) ListModels(c *gin.Context) <span class="cov8" title="1">{
        req, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("%s:%s/api/tags", ct.OLLAMA_HOST, ct.OLLAMA_PORT), nil)
        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                httputil.InternalServerError(c, err)
                return
        }</span>
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                httputil.InternalServerError(c, fmt.Errorf("failed to get response from model"))
                return
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        var jsonResp map[string]interface{}
        json.NewDecoder(resp.Body).Decode(&amp;jsonResp)
        var respArr []string
        for _, value := range jsonResp["models"].([]any) </span><span class="cov8" title="1">{
                value := value.(map[string]interface{})
                respArr = append(respArr, strings.Split(value["name"].(string), ":")[0])
        }</span>
        <span class="cov8" title="1">httputil.OK(c, respArr)</span>
}

func (b *Controller) Accesibilize(c *gin.Context) <span class="cov0" title="0">{
        body := c.MustGet(gin.BindKey).(*m.AccesibilizeBody)
        buf := new(bytes.Buffer)
        json.NewEncoder(buf).Encode(body)
        chanStream := make(chan string)
        go func() </span><span class="cov0" title="0">{
                defer close(chanStream)
                req, _ := http.NewRequest(http.MethodPost, fmt.Sprintf("%s:%s/api/generate", ct.OLLAMA_HOST, ct.OLLAMA_PORT), buf)
                resp, err := http.DefaultClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        httputil.InternalServerError(c, err)
                        return
                }</span>
                <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        httputil.InternalServerError(c, fmt.Errorf("failed to get response from model"))
                        return
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()
                reader := io.Reader(resp.Body)
                for </span><span class="cov0" title="0">{
                        buf := make([]byte, 8192)
                        n, err := reader.Read(buf)
                        if err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">httputil.InternalServerError(c, err)
                                return</span>
                        }
                        <span class="cov0" title="0">chanStream &lt;- string(buf[:n])</span>
                }
        }()

        <span class="cov0" title="0">c.Stream(func(_ io.Writer) bool </span><span class="cov0" title="0">{
                if msg, ok := &lt;-chanStream; ok </span><span class="cov0" title="0">{
                        c.SSEvent("message", msg)
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>

        })

}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controllers

import (
        "html-aiccesible/httputil"
        m "html-aiccesible/models"

        "github.com/gin-gonic/gin"
)

func (b *Controller) CreateComment(c *gin.Context) <span class="cov8" title="1">{
        body := c.MustGet(gin.BindKey).(*m.CreateCommentBody)
        user := c.MustGet("user").(*m.User)
        comment, err := b.CommentRepo.CreateComment(user, body)
        if err != nil </span><span class="cov8" title="1">{
                httputil.InternalServerError(c, err)
                return
        }</span>
        <span class="cov8" title="1">httputil.Created(c, comment)</span>
}

func (b *Controller) UpdateComment(c *gin.Context) <span class="cov8" title="1">{
        body := c.MustGet(gin.BindKey).(*m.UpdateCommentBody)
        user := c.MustGet("user").(*m.User)
        comment, err := b.CommentRepo.UpdateComment(user, body)
        if err != nil </span><span class="cov8" title="1">{
                httputil.InternalServerError(c, err)
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, comment)</span>
}

func (b *Controller) ListComments(c *gin.Context) <span class="cov8" title="1">{
        lo := c.MustGet("lo").(*m.ListOptions)
        getOpt := c.MustGet("getOpt").(*m.GetOptions)
        _, err := b.PostRepo.GetPost(getOpt.Id)
        if err != nil </span><span class="cov8" title="1">{
                httputil.NotFound(c, err)
                return
        }</span>
        <span class="cov8" title="1">comments, err := b.CommentRepo.ListComments(lo.Page, lo.Size, getOpt.Id)
        if err != nil </span><span class="cov0" title="0">{
                httputil.InternalServerError(c, err)
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, comments)</span>
}

func (b *Controller) GetComment(c *gin.Context) <span class="cov8" title="1">{
        getOpt := c.MustGet("getOpt").(*m.GetOptions)
        comment, err := b.CommentRepo.GetComment(getOpt.Id)
        if err != nil </span><span class="cov8" title="1">{
                httputil.NotFound(c, err)
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, comment)</span>
}

func (b *Controller) DeleteComment(c *gin.Context) <span class="cov8" title="1">{
        getOpt := c.MustGet("getOpt").(*m.GetOptions)
        user := c.MustGet("user").(*m.User)
        err := b.CommentRepo.DeleteComment(user, getOpt.Id)
        if err != nil </span><span class="cov8" title="1">{
                httputil.InternalServerError(c, err)
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, "Deleted comment successfully")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controllers

import (
        "html-aiccesible/httputil"
        "html-aiccesible/models"

        "github.com/gin-gonic/gin"
)

func (b *Controller) GetConfig(c *gin.Context) <span class="cov8" title="1">{
        user := c.MustGet("user").(*models.User)
        config, err := b.ConfigRepo.GetConfig(int(user.ID))
        if err != nil </span><span class="cov0" title="0">{
                httputil.NotFound(c, err)
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, config)</span>
}

func (b *Controller) UpdateConfig(c *gin.Context) <span class="cov8" title="1">{
        user := c.MustGet("user").(*models.User)
        configBody := c.MustGet(gin.BindKey).(*models.UpdateConfigBody)
        config, err := b.ConfigRepo.UpdateConfig(int(user.ID), configBody)
        if err != nil </span><span class="cov0" title="0">{
                httputil.InternalServerError(c, err)
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, config)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controllers

import (
        "html-aiccesible/models"
        "html-aiccesible/repositories"
)

type Controller struct {
        UserRepo    repositories.UserRepository
        ConfigRepo  repositories.ConfigRepository
        PostRepo    repositories.PostRepository
        CommentRepo repositories.CommentRepository
}

func NewController() *Controller <span class="cov8" title="1">{
        db := models.GetDB()
        return &amp;Controller{
                UserRepo:    repositories.UserRepo(db),
                ConfigRepo:  repositories.ConfigRepo(db),
                PostRepo:    repositories.PostRepo(db),
                CommentRepo: repositories.CommentRepo(db),
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package controllers

import (
        "html-aiccesible/httputil"
        m "html-aiccesible/models"

        "github.com/gin-gonic/gin"
)

func (b *Controller) CreatePost(c *gin.Context) <span class="cov8" title="1">{
        body := c.MustGet(gin.BindKey).(*m.CreatePostBody)
        user := c.MustGet("user").(*m.User)
        post, err := b.PostRepo.CreatePost(user, body)
        if err != nil </span><span class="cov0" title="0">{
                httputil.InternalServerError(c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.Created(c, post)</span>
}

func (b *Controller) UpdatePost(c *gin.Context) <span class="cov8" title="1">{
        body := c.MustGet(gin.BindKey).(*m.UpdatePostBody)
        user := c.MustGet("user").(*m.User)
        post, err := b.PostRepo.UpdatePost(user, body)
        if err != nil </span><span class="cov8" title="1">{
                httputil.InternalServerError(c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, post)</span>
}

func (b *Controller) GetPost(c *gin.Context) <span class="cov8" title="1">{
        getOpt := c.MustGet("getOpt").(*m.GetOptions)
        post, err := b.PostRepo.GetPost(getOpt.Id)
        if err != nil </span><span class="cov0" title="0">{
                httputil.NotFound(c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, post)</span>
}

func (b *Controller) DeletePost(c *gin.Context) <span class="cov8" title="1">{
        getOpt := c.MustGet("getOpt").(*m.GetOptions)
        user := c.MustGet("user").(*m.User)
        err := b.PostRepo.DeletePost(user, getOpt.Id)
        if err != nil </span><span class="cov8" title="1">{
                httputil.InternalServerError(c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, "Deleted post successfully")</span>
}

func (b *Controller) ListPosts(c *gin.Context) <span class="cov8" title="1">{
        lo := c.MustGet("lo").(*m.ListOptions)
        posts, err := b.PostRepo.ListPosts(lo.Page, lo.Size)
        if err != nil </span><span class="cov0" title="0">{
                httputil.InternalServerError(c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, posts)</span>
}

func (b *Controller) LikePost(c *gin.Context) <span class="cov8" title="1">{
        getOpt := c.MustGet("getOpt").(*m.GetOptions)
        user := c.MustGet("user").(*m.User)
        err := b.PostRepo.LikePost(user, getOpt.Id)
        if err != nil </span><span class="cov0" title="0">{
                httputil.InternalServerError(c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, "Toggle like post successfully")</span>
}

func (b *Controller) GetPostLikes(c *gin.Context) <span class="cov8" title="1">{
        getOpt := c.MustGet("getOpt").(*m.GetOptions)
        likes, err := b.PostRepo.GetPostLikes(getOpt.Id)
        if err != nil </span><span class="cov0" title="0">{
                httputil.InternalServerError(c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.OK(c, likes)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controllers

import (
        ct "html-aiccesible/constants"
        "html-aiccesible/httputil"
        "html-aiccesible/models"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v4"
        "golang.org/x/crypto/bcrypt"
)

func (b *Controller) CreateUser(c *gin.Context) <span class="cov8" title="1">{
        body := c.MustGet(gin.BindKey).(*models.CreateUserBody)
        user, err := b.UserRepo.CreateUser(body)
        if err != nil </span><span class="cov8" title="1">{
                httputil.InternalServerError[string](c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.Created[*models.User](c, user)</span>
}

func (b *Controller) UpdateUser(c *gin.Context) <span class="cov8" title="1">{
        body := c.MustGet(gin.BindKey).(*models.UpdateUserBody)
        user := c.MustGet("user").(*models.User)
        if user.ID != body.ID </span><span class="cov8" title="1">{
                httputil.Unauthorized[string](c, "You are not authorized to update this user")
                return
        }</span>
        <span class="cov8" title="1">user, err := b.UserRepo.UpdateUser(body)
        if err != nil </span><span class="cov8" title="1">{
                httputil.InternalServerError[string](c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.OK[*models.User](c, user)</span>
}

func (b *Controller) GetUser(c *gin.Context) <span class="cov8" title="1">{
        getOpt := c.MustGet("getOpt").(*models.GetOptions)
        user, err := b.UserRepo.GetUser(getOpt.Id)
        if err != nil </span><span class="cov8" title="1">{
                httputil.NotFound(c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.OK[*models.User](c, user)</span>
}

func (b *Controller) DeleteUser(c *gin.Context) <span class="cov8" title="1">{
        getOpt := c.MustGet("getOpt").(*models.GetOptions)
        err := b.UserRepo.DeleteUser(getOpt.Id)
        if err != nil </span><span class="cov8" title="1">{
                httputil.InternalServerError[string](c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.OK[string](c, "Deleted user successfully")</span>
}

func (b *Controller) ListUsers(c *gin.Context) <span class="cov8" title="1">{
        lo := c.MustGet("lo").(*models.ListOptions)
        users, err := b.UserRepo.ListUsers(lo.Page, lo.Size)
        if err != nil </span><span class="cov0" title="0">{
                httputil.InternalServerError[string](c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.OK[*[]models.User](c, &amp;users)</span>
}

func (b *Controller) Login(c *gin.Context) <span class="cov8" title="1">{
        body := c.MustGet(gin.BindKey).(*models.LoginUserBody)
        user, err := b.UserRepo.GetUserByUsername(body.Username)
        if err != nil </span><span class="cov0" title="0">{
                httputil.InternalServerError[string](c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">if user == nil </span><span class="cov0" title="0">{
                httputil.Unauthorized[string](c, "Invalid username or password")
                return
        }</span>

        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(body.Password))
        if err != nil </span><span class="cov0" title="0">{
                httputil.Unauthorized[string](c, "Invalid username or password")
                return
        }</span>
        <span class="cov8" title="1">token, err := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "sub": user.ID,
                "exp": time.Now().Add(time.Hour * 24 * 14).Unix(),
        }).SignedString([]byte(ct.JWT_SECRET))
        if err != nil </span><span class="cov0" title="0">{
                httputil.InternalServerError[string](c, err.Error())
                return
        }</span>
        <span class="cov8" title="1">httputil.OK[*models.LoginResponse](c, &amp;models.LoginResponse{Token: token})</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package httputil

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type HTTPResponse[T any] struct {
        Code   int    `json:"code"`
        Status string `json:"status"`
        Data   T      `json:"data"`
}

func newHTTPResponse[T any](code int, data T) HTTPResponse[T] <span class="cov8" title="1">{
        return HTTPResponse[T]{
                Code:   code,
                Status: http.StatusText(code),
                Data:   data,
        }
}</span>

// send using gin
func OK[T any](c *gin.Context, data T) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, newHTTPResponse(http.StatusOK, data))
}</span>

func Created[T any](c *gin.Context, data T) <span class="cov8" title="1">{
        c.JSON(http.StatusCreated, newHTTPResponse(http.StatusCreated, data))
}</span>

func BadRequest[T any](c *gin.Context, data T) <span class="cov8" title="1">{
        c.AbortWithStatusJSON(http.StatusBadRequest, newHTTPResponse(http.StatusBadRequest, data))
}</span>

func NotFound[T any](c *gin.Context, data T) <span class="cov8" title="1">{
        c.AbortWithStatusJSON(http.StatusNotFound, newHTTPResponse(http.StatusNotFound, data))
}</span>

func InternalServerError[T any](c *gin.Context, data T) <span class="cov8" title="1">{
        c.AbortWithStatusJSON(http.StatusInternalServerError, newHTTPResponse(http.StatusInternalServerError, data))
}</span>

func Unauthorized[T any](c *gin.Context, data T) <span class="cov8" title="1">{
        c.AbortWithStatusJSON(http.StatusUnauthorized, newHTTPResponse(http.StatusUnauthorized, data))
}</span>

func Forbidden[T any](c *gin.Context, data T) <span class="cov8" title="1">{
        c.AbortWithStatusJSON(http.StatusForbidden, newHTTPResponse(http.StatusForbidden, data))
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "fmt"
        ct "html-aiccesible/constants"
        "html-aiccesible/controllers"
        "html-aiccesible/httputil"
        "html-aiccesible/models"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v4"
)

func Auth(ctrl *controllers.Controller) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                tokenString := c.GetHeader("Authorization")

                if tokenString == "" </span><span class="cov8" title="1">{
                        httputil.Unauthorized[string](c, "No token provided")
                        return
                }</span>

                <span class="cov8" title="1">if len(tokenString) &lt; 7 || tokenString[:7] != "Bearer " </span><span class="cov0" title="0">{
                        httputil.Unauthorized[string](c, "Invalid token")
                        return
                }</span>
                <span class="cov8" title="1">tokenString = tokenString[7:]

                token, _ := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                        }</span>

                        <span class="cov8" title="1">return []byte(ct.JWT_SECRET), nil</span>
                })

                <span class="cov8" title="1">if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                        if time.Now().Unix() &gt; int64(claims["exp"].(float64)) </span><span class="cov0" title="0">{
                                httputil.Unauthorized[string](c, "Token expired")
                                return
                        }</span>
                        <span class="cov8" title="1">id, ok := claims["sub"]
                        if !ok </span><span class="cov0" title="0">{
                                httputil.Unauthorized[string](c, "Invalid token")
                                return
                        }</span>
                        <span class="cov8" title="1">user, err := ctrl.UserRepo.GetUser(int(id.(float64)))
                        if err != nil </span><span class="cov0" title="0">{
                                httputil.Unauthorized[string](c, "Invalid token")
                                return
                        }</span>
                        <span class="cov8" title="1">c.Set("user", user)
                        c.Next()</span>
                } else<span class="cov0" title="0"> {
                        httputil.Unauthorized[string](c, "Invalid token")
                        return
                }</span>
                <span class="cov8" title="1">c.Next()</span>
        }
}

func Admin() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                user := c.MustGet("user").(*models.User)
                if user.Username != ct.ADMIN_USERNAME </span><span class="cov8" title="1">{
                        httputil.Forbidden[string](c, "You are not allowed to access this resource")
                        return
                }</span>
                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
)

func SetupCors() gin.HandlerFunc <span class="cov8" title="1">{
        config := cors.DefaultConfig()
        config.AllowOrigins = []string{"http://localhost:3000"}
        config.AllowMethods = []string{"GET", "POST", "PUT", "DELETE", "PATCH"}
        config.AllowHeaders = []string{"Origin", "Content-Type", "Authorization"}
        config.AllowCredentials = true
        return cors.New(config)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "html-aiccesible/httputil"
        "html-aiccesible/models"
        "strconv"

        "github.com/gin-gonic/gin"
)

func ListOptions() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                page, err := strconv.Atoi(c.DefaultQuery("page", "1"))
                if err != nil </span><span class="cov0" title="0">{
                        httputil.BadRequest[string](c, "Invalid page")
                        return
                }</span>
                <span class="cov8" title="1">size, err := strconv.Atoi(c.DefaultQuery("size", "10"))
                if err != nil </span><span class="cov0" title="0">{
                        httputil.BadRequest[string](c, "Invalid size")
                        return
                }</span>
                <span class="cov8" title="1">lo := &amp;models.ListOptions{
                        Page: page,
                        Size: size,
                }
                c.Set("lo", lo)</span>
        }
}

func GetOptions() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                id, err := strconv.Atoi(c.Param("id"))
                if err != nil </span><span class="cov8" title="1">{
                        httputil.BadRequest[string](c, "Invalid ID")
                        return
                }</span>
                <span class="cov8" title="1">getOpt := &amp;models.GetOptions{
                        Id: id,
                }
                c.Set("getOpt", getOpt)</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import "github.com/gin-gonic/gin"

func JSONMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                c.Writer.Header().Set("Content-Type", "application/json")
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "errors"
        "fmt"
        "html-aiccesible/httputil"
        "net/http"
        "strings"
        "unicode"
        "unicode/utf8"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/stvp/rollbar"
)

var (
        ErrorInternalError = errors.New("whoops something went wrong")
)

func UcFirst(str string) string <span class="cov8" title="1">{
        for i, v := range str </span><span class="cov8" title="1">{
                return string(unicode.ToUpper(v)) + str[i+1:]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func LcFirst(str string) string <span class="cov0" title="0">{
        return strings.ToLower(str)
}</span>

func Split(src string) string <span class="cov8" title="1">{
        // don't split invalid utf8
        if !utf8.ValidString(src) </span><span class="cov0" title="0">{
                return src
        }</span>
        <span class="cov8" title="1">var entries []string
        var runes [][]rune
        lastClass := 0
        class := 0
        // split into fields based on class of unicode character
        for _, r := range src </span><span class="cov8" title="1">{
                switch true </span>{
                case unicode.IsLower(r):<span class="cov8" title="1">
                        class = 1</span>
                case unicode.IsUpper(r):<span class="cov8" title="1">
                        class = 2</span>
                case unicode.IsDigit(r):<span class="cov0" title="0">
                        class = 3</span>
                default:<span class="cov0" title="0">
                        class = 4</span>
                }
                <span class="cov8" title="1">if class == lastClass </span><span class="cov8" title="1">{
                        runes[len(runes)-1] = append(runes[len(runes)-1], r)
                }</span> else<span class="cov8" title="1"> {
                        runes = append(runes, []rune{r})
                }</span>
                <span class="cov8" title="1">lastClass = class</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt; len(runes)-1; i++ </span><span class="cov8" title="1">{
                if unicode.IsUpper(runes[i][0]) &amp;&amp; unicode.IsLower(runes[i+1][0]) </span><span class="cov8" title="1">{
                        runes[i+1] = append([]rune{runes[i][len(runes[i])-1]}, runes[i+1]...)
                        runes[i] = runes[i][:len(runes[i])-1]
                }</span>
        }
        // construct []string from results
        <span class="cov8" title="1">for _, s := range runes </span><span class="cov8" title="1">{
                if len(s) &gt; 0 </span><span class="cov8" title="1">{
                        entries = append(entries, string(s))
                }</span>
        }

        <span class="cov8" title="1">for index, word := range entries </span><span class="cov8" title="1">{
                if index == 0 </span><span class="cov8" title="1">{
                        entries[index] = UcFirst(word)
                }</span> else<span class="cov0" title="0"> {
                        entries[index] = LcFirst(word)
                }</span>
        }
        <span class="cov8" title="1">justString := strings.Join(entries, " ")
        return justString</span>
}

func ValidationErrorToText(e validator.FieldError) string <span class="cov8" title="1">{
        word := Split(e.Field())

        switch e.Tag() </span>{
        case "required":<span class="cov8" title="1">
                return fmt.Sprintf("%s is required", word)</span>
        case "max":<span class="cov8" title="1">
                return fmt.Sprintf("%s cannot be longer than %s", word, e.Param())</span>
        case "min":<span class="cov8" title="1">
                return fmt.Sprintf("%s must be longer than %s", word, e.Param())</span>
        case "email":<span class="cov0" title="0">
                return fmt.Sprintf("Invalid email format")</span>
        case "len":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be %s characters long", word, e.Param())</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s is not valid", word)</span>
}

// This method collects all errors and submits them to Rollbar
func Errors() gin.HandlerFunc <span class="cov8" title="1">{

        return func(c *gin.Context) </span><span class="cov8" title="1">{
                c.Next()
                // Only run if there are some errors to handle
                if len(c.Errors) &gt; 0 </span><span class="cov8" title="1">{
                        for _, e := range c.Errors </span><span class="cov8" title="1">{
                                // Find out what type of error it is
                                switch e.Type </span>{
                                case gin.ErrorTypePublic:<span class="cov0" title="0">
                                        // Only output public errors if nothing has been written yet
                                        if !c.Writer.Written() </span><span class="cov0" title="0">{
                                                c.JSON(c.Writer.Status(), gin.H{"Error": e.Error()})
                                        }</span>
                                case gin.ErrorTypeBind:<span class="cov8" title="1">
                                        errs := e.Err.(validator.ValidationErrors)
                                        list := make(map[string]string)
                                        for _, err := range errs </span><span class="cov8" title="1">{
                                                list[err.Field()] = ValidationErrorToText(err)
                                        }</span>
                                        <span class="cov8" title="1">httputil.BadRequest[map[string]string](c, list)</span>

                                default:<span class="cov0" title="0">
                                        // Log all other errors
                                        rollbar.RequestError(rollbar.ERR, c.Request, e.Err)</span>
                                }

                        }
                        // If there was no public or bind error, display default 500 message
                        <span class="cov8" title="1">if !c.Writer.Written() </span><span class="cov0" title="0">{
                                c.JSON(http.StatusInternalServerError, gin.H{"Error": ErrorInternalError.Error()})
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

import "gorm.io/gorm"

type Configuration struct {
        gorm.Model
        ShowLikes    bool   `json:"show_likes" gorm:"default:true"`
        ShowComments bool   `json:"show_comments" gorm:"default:true"`
        Theme        string `json:"theme" gorm:"default:'light'"`
        Language     string `json:"language" gorm:"default:'es'"`
        SizeTitle    float32`json:"size_title" gorm:"default:1.0"`
        SizeText     float32`json:"size_text" gorm:"default:1.0"`
        UserID       uint   `json:"-"`
}

type UpdateConfigBody struct {
        ShowLikes    bool   `json:"show_likes"`
        ShowComments bool   `json:"show_comments"`
        Theme        string `json:"theme"`
        Language     string `json:"language"`
        SizeTitle    float32`json:"size_title"`
        SizeText     float32`json:"size_text"`
}

func FillConfigDefaults(config *Configuration) Configuration <span class="cov8" title="1">{
        config.ShowLikes = true
        config.ShowComments = true  
        config.Theme = "light"
        config.Language = "es"
        config.SizeTitle = 1.0
        config.SizeText = 1.0
        return *config
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import (
        "fmt"
        ct "html-aiccesible/constants"

        "gorm.io/driver/mysql"

        "gorm.io/gorm"
)

var db *gorm.DB

func GetDB() *gorm.DB <span class="cov8" title="1">{
        if db == nil </span><span class="cov8" title="1">{
                gormDB, err := gorm.Open(mysql.Open(getDsn()), &amp;gorm.Config{})
                if err != nil </span><span class="cov0" title="0">{
                        panic("failed to connect database")</span>
                }
                <span class="cov8" title="1">gormDB.AutoMigrate(
                        &amp;User{},
                        &amp;Configuration{},
                        &amp;Post{},
                        &amp;Comment{},
                )
                db = gormDB</span>
        }
        <span class="cov8" title="1">return db</span>
}

func getDsn() string <span class="cov8" title="1">{
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local",
                ct.MYSQL_USER,
                ct.MYSQL_PASSWORD,
                ct.MYSQL_HOST,
                ct.MYSQL_PORT,
                ct.MYSQL_DATABASE,
        )
        return dsn
}</span>

func CreateDefaultUser() <span class="cov8" title="1">{
        db := GetDB()
        username := ct.ADMIN_USERNAME
        var user User
        db.Where("username = ?", username).First(&amp;user)
        if user.ID == 0 </span><span class="cov0" title="0">{
                user.Username = username
                pwd := ct.ADMIN_PASSWORD
                hash, err := HashPassword(pwd)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">user.Password = hash
                user.Config = FillConfigDefaults(&amp;Configuration{})
                db.Create(&amp;user)</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import (
        ct "html-aiccesible/constants"
        "strconv"

        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

type User struct {
        gorm.Model
        Username   string        `json:"username" gorm:"unique"`
        Password   string        `json:"-"`
        Config     Configuration `json:"-"`
        Posts      []Post        `json:"-"`
        LikedPosts []*Post       `json:"-" gorm:"many2many:post_likes;"`
        Comments   []Comment     `json:"-"`
}

type CreateUserBody struct {
        Username string `json:"username" binding:"required,min=4,max=20"`
        Password string `json:"password" binding:"required,min=8,max=20"`
}

type UpdateUserBody struct {
        ID       uint   `json:"id" binding:"required"`
        Username string `json:"username" binding:"required,min=4,max=20"`
        Password string `json:"password" binding:"required,min=8,max=20"`
}

type LoginUserBody struct {
        Username string `json:"username" binding:"required,min=4,max=20"`
        Password string `json:"password" binding:"required,min=8,max=20"`
}

type LoginResponse struct {
        Token string `json:"token"`
}

func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        cost, err := strconv.Atoi(ct.BCRYPT_COST)
        if err != nil </span><span class="cov0" title="0">{
                panic("BCRYPT_COST must be an integer")</span>
        }
        <span class="cov8" title="1">hash, err := bcrypt.GenerateFromPassword([]byte(password), cost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(hash), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package repositories

import (
        "errors"
        m "html-aiccesible/models"

        "gorm.io/gorm"
)

type CommentRepository interface {
        ListComments(page, size, postID int) ([]m.Comment, error)
        GetComment(commentID int) (*m.Comment, error)
        CreateComment(user *m.User, commentBody *m.CreateCommentBody) (*m.Comment, error)
        UpdateComment(user *m.User, commentBody *m.UpdateCommentBody) (*m.Comment, error)
        DeleteComment(user *m.User, commentID int) error
}

type commentRepository struct {
        DB *gorm.DB
}

func CommentRepo(db *gorm.DB) CommentRepository <span class="cov8" title="1">{
        return &amp;commentRepository{
                DB: db,
        }
}</span>

func (r *commentRepository) ListComments(page, size, postID int) ([]m.Comment, error) <span class="cov8" title="1">{
        var comments []m.Comment
        res := r.DB.Where("post_id = ?", postID).Limit(size).Offset((page - 1) * size).Find(&amp;comments)
        if res.Error != nil </span><span class="cov0" title="0">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return comments, nil</span>
}

func (r *commentRepository) GetComment(commentID int) (*m.Comment, error) <span class="cov8" title="1">{
        var comment m.Comment
        res := r.DB.First(&amp;comment, commentID)
        if res.Error != nil </span><span class="cov8" title="1">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return &amp;comment, nil</span>
}

func (r *commentRepository) CreateComment(user *m.User, commentBody *m.CreateCommentBody) (*m.Comment, error) <span class="cov8" title="1">{
        comment := &amp;m.Comment{
                Title:   commentBody.Title,
                Content: commentBody.Content,
                PostID:  commentBody.PostID,
                UserID:  user.ID,
        }
        res := r.DB.Create(comment)
        if res.Error != nil </span><span class="cov8" title="1">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return comment, nil</span>
}

func (r *commentRepository) UpdateComment(user *m.User, commentBody *m.UpdateCommentBody) (*m.Comment, error) <span class="cov8" title="1">{
        comment, err := r.GetComment(int(commentBody.ID))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if comment.UserID != user.ID </span><span class="cov8" title="1">{
                return nil, errors.New("user is not the owner of the comment")
        }</span>
        <span class="cov8" title="1">comment.Title = commentBody.Title
        comment.Content = commentBody.Content
        res := r.DB.Save(comment)
        if res.Error != nil </span><span class="cov0" title="0">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return comment, nil</span>
}

func (r *commentRepository) DeleteComment(user *m.User, commentID int) error <span class="cov8" title="1">{
        comment, err := r.GetComment(commentID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if comment.UserID != user.ID </span><span class="cov8" title="1">{
                return errors.New("user is not the owner of the comment")
        }</span>
        <span class="cov8" title="1">res := r.DB.Delete(&amp;m.Comment{}, commentID)
        if res.Error != nil </span><span class="cov0" title="0">{
                return res.Error
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package repositories

import (
        "encoding/json"
        "html-aiccesible/models"

        "gorm.io/gorm"
)

type ConfigRepository interface {
        UpdateConfig(userID int, configBody *models.UpdateConfigBody) (*models.Configuration, error)
        GetConfig(userID int) (*models.Configuration, error)
}

type configRepository struct {
        DB *gorm.DB
}

func ConfigRepo(db *gorm.DB) ConfigRepository <span class="cov8" title="1">{
        return &amp;configRepository{
                DB: db,
        }
}</span>

func (r *configRepository) UpdateConfig(userID int, configBody *models.UpdateConfigBody) (*models.Configuration, error) <span class="cov8" title="1">{
        var config map[string]interface{}
        configBytes, err := json.Marshal(configBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(configBytes, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">res := r.DB.Model(models.Configuration{}).Where("user_id = ?", userID).Updates(config)

        if res.Error != nil </span><span class="cov0" title="0">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return r.GetConfig(userID)</span>
}

func (r *configRepository) GetConfig(userID int) (*models.Configuration, error) <span class="cov8" title="1">{
        var config models.Configuration
        res := r.DB.Where("user_id = ?", userID).First(&amp;config)
        if res.Error != nil </span><span class="cov0" title="0">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return &amp;config, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package repositories

import (
        "errors"
        m "html-aiccesible/models"

        "gorm.io/gorm"
)

type PostRepository interface {
        CreatePost(user *m.User, postBody *m.CreatePostBody) (*m.Post, error)
        UpdatePost(user *m.User, postBody *m.UpdatePostBody) (*m.Post, error)
        GetPost(postID int) (*m.Post, error)
        ListPosts(page, size int) ([]m.Post, error)
        DeletePost(user *m.User, postID int) error
        LikePost(user *m.User, postID int) error
        GetPostLikes(postID int) (int, error)
}

type postRepository struct {
        DB *gorm.DB
}

func PostRepo(db *gorm.DB) PostRepository <span class="cov8" title="1">{
        return &amp;postRepository{
                DB: db,
        }
}</span>

func (r *postRepository) CreatePost(user *m.User, postBody *m.CreatePostBody) (*m.Post, error) <span class="cov8" title="1">{
        post := &amp;m.Post{
                Title:       postBody.Title,
                Description: postBody.Description,
                Before:      postBody.Before,
                After:       postBody.After,
                UserID:      user.ID,
        }
        res := r.DB.Create(post)
        if res.Error != nil </span><span class="cov0" title="0">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return post, nil</span>
}

func (r *postRepository) UpdatePost(user *m.User, postBody *m.UpdatePostBody) (*m.Post, error) <span class="cov8" title="1">{
        post, err := r.GetPost(int(postBody.ID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if user.ID != post.UserID </span><span class="cov8" title="1">{
                return nil, errors.New("user is not the owner of the post")
        }</span>
        <span class="cov8" title="1">post.Title = postBody.Title
        post.Description = postBody.Description
        post.Before = postBody.Before
        post.After = postBody.After
        res := r.DB.Save(post)
        if res.Error != nil </span><span class="cov0" title="0">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return post, nil</span>
}

func (r *postRepository) GetPost(postID int) (*m.Post, error) <span class="cov8" title="1">{
        var post m.Post
        res := r.DB.Preload("Likes").Preload("Comments").First(&amp;post, postID)
        if res.Error != nil </span><span class="cov8" title="1">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return &amp;post, nil</span>
}

func (r *postRepository) ListPosts(page, size int) ([]m.Post, error) <span class="cov8" title="1">{
        var posts []m.Post
        res := r.DB.Preload("Likes").Preload("Comments").Limit(size).Offset((page - 1) * size).Find(&amp;posts)
        if res.Error != nil </span><span class="cov0" title="0">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return posts, nil</span>
}

func (r *postRepository) DeletePost(user *m.User, postID int) error <span class="cov8" title="1">{
        post, err := r.GetPost(postID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if post.UserID != user.ID </span><span class="cov8" title="1">{
                return errors.New("user is not the owner of the post")
        }</span>
        <span class="cov8" title="1">res := r.DB.Delete(&amp;m.Post{}, postID)
        if res.Error != nil </span><span class="cov0" title="0">{
                return res.Error
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *postRepository) LikePost(user *m.User, postID int) error <span class="cov8" title="1">{
        post, err := r.GetPost(postID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // if the user already liked the post, remove the like
        <span class="cov8" title="1">for _, like := range post.Likes </span><span class="cov8" title="1">{
                if like.ID == user.ID </span><span class="cov8" title="1">{
                        err = r.DB.Model(post).Association("Likes").Delete(user)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
        }

        // if user did not like the post, add the like
        <span class="cov8" title="1">err = r.DB.Model(post).Association("Likes").Append(user)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *postRepository) GetPostLikes(postID int) (int, error) <span class="cov8" title="1">{
        post, err := r.GetPost(postID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return len(post.Likes), nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package repositories

import (
        "errors"
        "gorm.io/gorm"
        "html-aiccesible/models"
)

type UserRepository interface {
        CreateUser(userBody *models.CreateUserBody) (*models.User, error)
        GetUser(id int) (*models.User, error)
        GetUserByUsername(username string) (*models.User, error)
        UpdateUser(userBody *models.UpdateUserBody) (*models.User, error)
        DeleteUser(id int) error
        ListUsers(page, size int) ([]models.User, error)
}

type userRepository struct {
        DB *gorm.DB
}

func UserRepo(db *gorm.DB) UserRepository <span class="cov8" title="1">{
        return &amp;userRepository{
                DB: db,
        }
}</span>

func (r *userRepository) CreateUser(userBody *models.CreateUserBody) (*models.User, error) <span class="cov8" title="1">{
        hash, err := models.HashPassword(userBody.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">user := &amp;models.User{
                Username: userBody.Username,
                Password: hash,
                Config:   models.FillConfigDefaults(&amp;models.Configuration{}),
        }
        res := r.DB.Create(user)
        if res.Error != nil </span><span class="cov8" title="1">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

func (r *userRepository) GetUser(id int) (*models.User, error) <span class="cov8" title="1">{
        var user models.User
        res := r.DB.First(&amp;user, id)
        if res.Error != nil </span><span class="cov8" title="1">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *userRepository) GetUserByUsername(username string) (*models.User, error) <span class="cov8" title="1">{
        var user models.User
        res := r.DB.Where("username = ?", username).First(&amp;user)
        if res.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(res.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, res.Error</span>
        }
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *userRepository) UpdateUser(userBody *models.UpdateUserBody) (*models.User, error) <span class="cov8" title="1">{
        hash, err := models.HashPassword(userBody.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">user := &amp;models.User{
                Username: userBody.Username,
                Password: hash,
        }
        res := r.DB.Model(&amp;models.User{}).Where("id = ?", userBody.ID).Updates(user)
        if res.Error != nil </span><span class="cov8" title="1">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return r.GetUser(int(userBody.ID))</span>
}

func (r *userRepository) DeleteUser(id int) error <span class="cov8" title="1">{
        _, err := r.GetUser(id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">res := r.DB.Delete(&amp;models.User{}, id)
        if res.Error != nil </span><span class="cov0" title="0">{
                return res.Error
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *userRepository) ListUsers(page, size int) ([]models.User, error) <span class="cov8" title="1">{
        users := []models.User{}
        res := r.DB.Limit(size).Offset((page - 1) * size).Find(&amp;users)
        if res.Error != nil </span><span class="cov0" title="0">{
                return nil, res.Error
        }</span>
        <span class="cov8" title="1">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package routes

import (
        "html-aiccesible/controllers"
        "html-aiccesible/middleware"
        m "html-aiccesible/middleware"
        "html-aiccesible/models"

        "github.com/gin-gonic/gin"
)

func SetUpRouter() *gin.Engine <span class="cov8" title="1">{
        r := gin.Default()
        r.Use(middleware.SetupCors())
        c := controllers.NewController()
        api := r.Group("/api", m.Errors(), m.JSONMiddleware())
        </span><span class="cov8" title="1">{
                user := api.Group("/user")
                </span><span class="cov8" title="1">{
                        user.POST("/add", gin.Bind(models.CreateUserBody{}), c.CreateUser)
                        user.PUT("/update", m.Auth(c), gin.Bind(models.UpdateUserBody{}), c.UpdateUser)
                        user.GET("/get/:id", m.GetOptions(), c.GetUser)
                        user.DELETE("/delete/:id", m.GetOptions(), m.Auth(c), m.Admin(), c.DeleteUser)
                        user.GET("/list", m.ListOptions(), c.ListUsers)
                        user.POST("/login", gin.Bind(models.LoginUserBody{}), c.Login)
                }</span>
                <span class="cov8" title="1">config := api.Group("/config", m.Auth(c))
                </span><span class="cov8" title="1">{
                        config.GET("/get", c.GetConfig)
                        config.PUT("/update", gin.Bind(models.UpdateConfigBody{}), c.UpdateConfig)
                }</span>
                <span class="cov8" title="1">post := api.Group("/post")
                </span><span class="cov8" title="1">{
                        post.POST("/add", m.Auth(c), gin.Bind(models.CreatePostBody{}), c.CreatePost)
                        post.PUT("/update", m.Auth(c), gin.Bind(models.UpdatePostBody{}), c.UpdatePost)
                        post.GET("/get/:id", m.GetOptions(), c.GetPost)
                        post.DELETE("/delete/:id", m.Auth(c), m.GetOptions(), c.DeletePost)
                        post.GET("/list", m.ListOptions(), c.ListPosts)
                        post.PATCH("/like/:id", m.Auth(c), m.GetOptions(), c.LikePost)
                        post.GET("/likes/:id", m.GetOptions(), c.GetPostLikes)
                }</span>
                <span class="cov8" title="1">comment := api.Group("/comment")
                </span><span class="cov8" title="1">{
                        comment.POST("/add", m.Auth(c), gin.Bind(models.CreateCommentBody{}), c.CreateComment)
                        comment.PUT("/update", m.Auth(c), gin.Bind(models.UpdateCommentBody{}), c.UpdateComment)
                        comment.GET("/get/:id", m.GetOptions(), c.GetComment)
                        comment.DELETE("/delete/:id", m.Auth(c), m.GetOptions(), c.DeleteComment)
                        comment.GET("/list/:id", m.GetOptions(), m.ListOptions(), c.ListComments)
                }</span>
                <span class="cov8" title="1">AI := api.Group("/models")
                </span><span class="cov8" title="1">{
                        AI.GET("/list", c.ListModels)
                        AI.POST("/accesibilize", gin.Bind(models.AccesibilizeBody{}), c.Accesibilize)
                }</span>
        }
        <span class="cov8" title="1">return r</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
